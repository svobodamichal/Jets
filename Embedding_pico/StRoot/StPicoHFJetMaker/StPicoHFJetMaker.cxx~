#include "StPicoHFJetMaker.h"

//FastJet 3
#include "fastjet/config.h"
#include "fastjet/PseudoJet.hh"
#include "fastjet/JetDefinition.hh"
#include "fastjet/ClusterSequence.hh"
#include "fastjet/ClusterSequenceArea.hh"
#include "fastjet/Selector.hh"
#include "fastjet/Subtractor.hh"
#include "fastjet/JetMedianBackgroundEstimator.hh"

using namespace fastjet;

ClassImp(StPicoHFJetMaker)

// was
//
//StPicoHFJetMaker::StPicoHFJetMaker(char const* name, StPicoDstMaker* picoMaker, char const* outputBaseFileName) : StPicoJetMaker(name, picoMaker, outputBaseFileName) {

//}


//jana chagned to

StPicoHFJetMaker::StPicoHFJetMaker(char const* name, StPicoDstMaker* picoMaker, char const* outputBaseFileName, char const* inputHFListHFtree = "") :
StPicoJetMaker(name, picoMaker, outputBaseFileName, inputHFListHFtree), mOutFileBaseName(outputBaseFileName){


  // constructor
}

// _________________________________________________________
StPicoHFJetMaker::~StPicoHFJetMaker() {
  // destructor
}

// _________________________________________________________
int StPicoHFJetMaker::InitJets() {
  // -- INITIALIZE USER HISTOGRAMS ETC HERE -------------------
  //    add them to the output list mOutList which is automatically written

  // EXAMPLE //  mOutList->Add(new TH1F(...));
  // EXAMPLE //  TH1F* hist = static_cast<TH1F*>(mOutList->Last());

    int npTleadbins = 25;
    float pTleadmin = 0;
    float pTleadmax = 25;
    int nptbins = 800;
    float ptminbin = -100;
    float ptmaxbin = 100;
    int netabins = 100*2;
    float etaminbin = -1;
    float etamaxbin = 1;
    int nphibins = 120;
    float phiminbin = 0;//-TMath::Pi();
    float phimaxbin = TMath::TwoPi();
    int zbins = 50;
    float zmin = -50;
    float zmax = 50;
    int npttrackbins = 120;
    float pttrackmin = 0;
    float pttrackmax = 30;

    //General track QA
    mOutList->Add(new TH2D("heta_phi_tr", "track eta vs phi;#eta;#phi", netabins, etaminbin, etamaxbin, nphibins, phiminbin, phimaxbin));
    mOutList->Add(new TH1D("hpT_tr", "track pT; p_{T} [GeV/c]", npttrackbins, pttrackmin, pttrackmax));
    mOutList->Add(new TH2D("hdca_z_tr", "track DCA vs z-vertex", 90, 0, 3, zbins , zmin, zmax));
    mOutList->Add(new TH1D("hdca_tr", "track DCA", 90, 0, 3));
    mOutList->Add(new TH2D("hdca_pT", "track DCA vs. p_{T}", 90, 0, 3, npttrackbins, pttrackmin, pttrackmax));

    if (isMcMode()) {
        //TODO: Add required histograms for MC Mode
    }

    if (!isMcMode()) {
        for(int r = 0; r < fR.size(); r++) {
            //TString hname = Form("hpT_pTlead_R0%.0lf",fR[r]*10);
            //mOutList->Add(new TH2D(hname, "jet pTcorr vs pTleading; p_{T} [GeV/c]; p_{T}^{lead} [GeV/c]", nptbins, ptminbin, ptmaxbin, npTleadbins, pTleadmin, pTleadmax));
	    TString hname = Form("hpT_R0%.0lf",fR[r]*10);
	    mOutList->Add(new TH1D(hname, "pT; p_{T} [GeV/c]", nptbins, ptminbin, ptmaxbin)); 

            //hname = Form("heta_phi_R0%.0lf",fR[r]*10);
            //mOutList->Add(new TH2D(hname, "jet eta vs phi;#eta;#phi", netabins, etaminbin, etamaxbin, nphibins, phiminbin, phimaxbin));

	    hname = Form("heta_R0%.0lf",fR[r]*10);
            mOutList->Add(new TH1D(hname, "jet eta;#eta", netabins, etaminbin, etamaxbin));

	    hname = Form("hphi_R0%.0lf",fR[r]*10);
            mOutList->Add(new TH1D(hname, "jet phi;#phi", nphibins, phiminbin, phimaxbin));

            hname = Form("hjetarea_cut_R0%.0lf",fR[r]*10);
            mOutList->Add(new TH1D(hname,"jet area after cut", 100, 0, 1));

            hname = Form("hjetarea_R0%.0lf",fR[r]*10);
            mOutList->Add(new TH1D(hname,"jet area", 100, 0, 1));

            hname = Form("hjetpTarea_R0%.0lf",fR[r]*10);
            mOutList->Add(new TH2D(hname,"jet pTmeasured vs area", nptbins, ptminbin, ptmaxbin, 100, 0, 1));

            hname = Form("hjetpTcorrArea_R0%.0lf",fR[r]*10);
            mOutList->Add(new TH2D(hname,"jet pTreco vs area", nptbins, ptminbin, ptmaxbin, 100, 0, 1));

            hname = Form("hrho_R0%.0lf",fR[r]*10);
            mOutList->Add(new TH1D(hname,"rho",50,0,50));

            hname = Form("hjetstructure_R0%.0lf",fR[r]*10);
            mOutList->Add(new TH2D(hname,"jet constituents pT vs pTlead ; p_{T}^{part} [GeV/c]; p_{T}^{lead} [GeV/c]", 50, 0, 25, npTleadbins, pTleadmin, pTleadmax));

            hname = Form("hnparticlesinjet_R0%.0lf",fR[r]*10);
            mOutList->Add(new TH2D(hname,"#particles in jet vs jet pT; # of particels; p_{T}^{lead} [GeV/c]", 20, 0, 20, npTleadbins, pTleadmin, pTleadmax));


            for(Int_t pTl = 0; pTl < npTlead; pTl++) {
                hname = Form("hpT_pTl%i_R0%.0lf",pTl,fR[r]*10);
                TString hdesc = Form("jet pT for pTlead>%i ; p_{T} [GeV/c]",pTl);
                mOutList->Add(new TH1D(hname, hdesc, nptbins, ptminbin, ptmaxbin));
            }
        }
    
}

    if (isMakerMode() == StPicoJetMaker::kWrite) {
        //TODO: Fill trees with required variables
    }

    //mRefmultCorrUtil->setVzForWeight(6, -6.0, 6.0);
    //mRefmultCorrUtil->readScaleForWeight("StRoot/StRefMultCorr/macros/weight_grefmult_VpdnoVtx_Vpd5_Run16.txt");
  return kStOK;
}

// _________________________________________________________
void StPicoHFJetMaker::ClearJets(Option_t *opt="") {
  
  return;
}

// _________________________________________________________
int StPicoHFJetMaker::FinishJets() {

  return kStOK;
}

// _________________________________________________________
int StPicoHFJetMaker::MakeJets() {
    vector<PseudoJet> jetTracks;
    for (int i = 0; i < mIdxPicoParticles.size(); i++) {
        StPicoTrack *trk = mPicoDst->track(mIdxPicoParticles[i]);

        float pT = trk->gPt();
        float eta = trk->gMom().pseudoRapidity();
        float phi = trk->gMom().phi();
        float dca = (mPrimVtx - trk->origin()).mag();

        static_cast<TH1D*>(mOutList->FindObject("hpT_tr"))->Fill(pT);
        static_cast<TH2D*>(mOutList->FindObject("heta_phi_tr"))->Fill(eta, phi + TMath::Pi());
        static_cast<TH2D*>(mOutList->FindObject("hdca_z_tr"))->Fill(dca, mPrimVtx.z());
        static_cast<TH2D*>(mOutList->FindObject("hdca_pT"))->Fill(dca, pT);
        static_cast<TH1D*>(mOutList->FindObject("hdca_tr"))->Fill(dca);


        PseudoJet inputParticle(trk->gMom().x(), trk->gMom().y(), trk->gMom().z(), trk->gMom().mag());
        jetTracks.push_back(inputParticle);
    }


    for (int i = 0; i < fR.size(); i++) {
        float maxRapJet = mPicoCuts->getCutEta() - fR[i];

        if (isMcMode()) {
          //TODO: Add MC code here
        } else {
            JetDefinition jet_def(antikt_algorithm, fR[i]);
            // jet area definition
            GhostedAreaSpec area_spec(fGhostMaxrap);
            //AreaDefinition area_def(active_area, are0a_spec);
            AreaDefinition area_def(active_area_explicit_ghosts, GhostedAreaSpec(fGhostMaxrap, 1, 0.01));

            //run jet reconstruction
            ClusterSequenceArea clust_seq_hard(jetTracks, jet_def, area_def);
            vector<PseudoJet> jets_all = sorted_by_pt(clust_seq_hard.inclusive_jets(fJetPtMin));
            Selector Fiducial_cut_selector = SelectorAbsEtaMax(maxRapJet); // Fiducial cut for jets
            vector<PseudoJet> jets = Fiducial_cut_selector(jets_all);

            // background estimation
            JetDefinition jet_def_bkgd(kt_algorithm, fRBg);
            AreaDefinition area_def_bkgd(active_area_explicit_ghosts,GhostedAreaSpec(fGhostMaxrap, 1, 0.01));
            Selector selector = SelectorAbsEtaMax(1.0) * (!SelectorNHardest(nJetsRemove));
            JetMedianBackgroundEstimator bkgd_estimator(selector, jet_def_bkgd, area_def_bkgd);
            bkgd_estimator.set_particles(jetTracks);

            float rho   = bkgd_estimator.rho();
            float rho_sigma = bkgd_estimator.sigma();

            static_cast<TH1D*>(mOutList->FindObject(Form("hrho_R0%.0lf",fR[i]*10)))->Fill(rho);

            for(Int_t pjet = 0; pjet < jets.size(); pjet++) {
                float phi_jet = jets[pjet].phi();
                float eta_jet = jets[pjet].eta();
                float pT_jet = jets[pjet].perp();
                float area_jet = jets[pjet].area();
                vector<PseudoJet> constituents = sorted_by_pt(jets[pjet].constituents());
                float pTlead = constituents[0].perp();
                float pTcorr_jet = pT_jet - area_jet*rho;

                //set acceptance
                float etaMinCut = -(maxRapJet);
                float etaMaxCut = (maxRapJet);

                if(eta_jet < etaMinCut || eta_jet > etaMaxCut) continue; // fiducial acceptance

                int nparticles = constituents.size();

                static_cast<TH1D*>(mOutList->FindObject(Form("hjetarea_R0%.0lf",fR[i]*10)))->Fill(area_jet);
                static_cast<TH2D*>(mOutList->FindObject(Form("hjetpTarea_R0%.0lf",fR[i]*10)))->Fill(pT_jet, area_jet);
                static_cast<TH2D*>(mOutList->FindObject(Form("hjetpTcorrArea_R0%.0lf",fR[i]*10)))->Fill(pTcorr_jet, area_jet);

                for (int j = 0; j < fAcuts.size(); j++) {
                    if(area_jet < fAcuts[j]) continue;

                    static_cast<TH1D*>(mOutList->FindObject(Form("hjetarea_cut_R0%.0lf",fR[i]*10)))->Fill(area_jet);
                    //static_cast<TH2D*>(mOutList->FindObject(Form("hpT_pTlead_R0%.0lf",fR[i]*10)))->Fill(pTcorr_jet, pTlead);
		    static_cast<TH1D*>(mOutList->FindObject(Form("hpT_R0%.0lf",fR[i]*10)))->Fill(pT_jet);
                    //static_cast<TH2D*>(mOutList->FindObject(Form("heta_phi_R0%.0lf", fR[i]*10)))->Fill(eta_jet, phi_jet);
		    static_cast<TH1D*>(mOutList->FindObject(Form("heta_R0%.0lf", fR[i]*10)))->Fill(eta_jet);
		    static_cast<TH1D*>(mOutList->FindObject(Form("hphi_R0%.0lf", fR[i]*10)))->Fill(phi_jet);
                    static_cast<TH2D*>(mOutList->FindObject(Form("hnparticlesinjet_R0%.0lf",fR[i]*10)))->Fill(nparticles, pTlead);


                    for(Int_t pTl = 0; pTl < npTlead; pTl++) {
                        if(pTl < pTlead) {
                            static_cast<TH1D*>(mOutList->FindObject(Form("hpT_pTl%i_R0%.0lf",pTl,fR[i]*10)))->Fill(pTcorr_jet);
                        }
                    }
                }

                for(int pr = 0; pr < nparticles; pr++) {
                    for (int j = 0; j < fAcuts.size(); j++) {
                        if(area_jet < fAcuts[j]) continue;

                        float part_pT = constituents[pr].perp();
                        static_cast<TH2D*>(mOutList->FindObject(Form("hjetstructure_R0%.0lf",fR[i]*10)))->Fill(part_pT, pTlead);
                    }
                }


            }
        }
    }

  return kStOK;
}

